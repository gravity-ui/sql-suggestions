{"version":3,"file":"mysqlAutocompleteParser.js","sourceRoot":"","sources":["../../../src/parsers/mysql/mysqlAutocompleteParser.ts"],"names":[],"mappings":"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","sourcesContent":["import {CharStreams, CommonTokenStream, TokenStream, ANTLRErrorListener} from 'antlr4ng';\nimport * as c3 from 'antlr4-c3';\n\nimport {MySqlLexer} from './generated/MySqlLexer.js';\nimport {MySqlParser} from './generated/MySqlParser.js';\n// import {MySqlParserVisitor} from './generated/MySqlParserVisitor.js';\n\ninterface CursorPosition {\n    line: number;\n    column: number;\n}\n\ninterface ParserSyntaxError {\n    message: string;\n    startLine: number;\n    startColumn: number;\n}\n\ninterface KeywordSuggestion {\n    value: string;\n}\n\n// class Visitor extends MySqlParserVisitor<{}> {\n//     constructor() {\n//         super();\n//     }\n\n//     visitCreateDatabase = (a) => {\n//         return {};\n//     };\n// }\n\nconst possibleIdentifierPrefix = /[\\w]$/;\nconst lineSeparator = /\\n|\\r|\\r\\n/g;\n\nfunction findCursorTokenIndex(\n    tokenStream: TokenStream,\n    cursor: CursorPosition,\n): number | undefined {\n    // Cursor position is 1-based, while token's charPositionInLine is 0-based\n    const cursorCol = cursor.column - 1;\n    for (let i = 0; i < tokenStream.size; i++) {\n        const t = tokenStream.get(i);\n\n        const tokenStartCol = t.column;\n        const tokenEndCol = t.column + (t.text?.length || 0);\n        const tokenStartLine = t.line;\n        const tokenEndLine =\n            t.type !== MySqlLexer.SPACE || !t.text\n                ? tokenStartLine\n                : tokenStartLine + (t.text.match(lineSeparator)?.length || 0);\n\n        // tokenEndCol makes sense only if tokenStartLine === tokenEndLine\n        if (\n            tokenEndLine > cursor.line ||\n            (tokenStartLine === cursor.line && tokenEndCol > cursorCol)\n        ) {\n            if (\n                i > 0 &&\n                tokenStartLine === cursor.line &&\n                tokenStartCol === cursorCol &&\n                // If previous token is an identifier (i.e. word, not a symbol),\n                // then we want to return previous token index\n                possibleIdentifierPrefix.test(tokenStream.get(i - 1).text || '')\n            ) {\n                return i - 1;\n            } else if (tokenStream.get(i).type === MySqlLexer.SPACE) {\n                return i + 1;\n            }\n            return i;\n        }\n    }\n    return undefined;\n}\n\nclass MySqlErrorListener implements ANTLRErrorListener {\n    errors: ParserSyntaxError[];\n\n    constructor() {\n        this.errors = [];\n    }\n\n    syntaxError(\n        _recognizer: any,\n        _offendingSymbol: any,\n        startLine: number,\n        startColumn: number,\n        message: string,\n    ) {\n        this.errors.push({message, startLine, startColumn});\n    }\n\n    reportAmbiguity() {}\n\n    reportAttemptingFullContext() {}\n\n    reportContextSensitivity() {}\n}\n\nexport function parseMySqlQueryWithoutCursor(query: string): {errors: ParserSyntaxError[]} {\n    const inputStream = CharStreams.fromString(query);\n    const lexer = new MySqlLexer(inputStream);\n    const tokenStream = new CommonTokenStream(lexer);\n    const parser = new MySqlParser(tokenStream);\n    const errorListener = new MySqlErrorListener();\n\n    parser.removeErrorListeners();\n    parser.addErrorListener(errorListener);\n    parser.root();\n\n    return {errors: errorListener.errors};\n}\n\nexport function parseMySqlQuery(\n    query: string,\n    cursor: CursorPosition,\n): {errors: ParserSyntaxError[]; suggestKeywords: KeywordSuggestion[]} {\n    const inputStream = CharStreams.fromString(query);\n    const lexer = new MySqlLexer(inputStream);\n    const tokenStream = new CommonTokenStream(lexer);\n    const parser = new MySqlParser(tokenStream);\n    const errorListener = new MySqlErrorListener();\n\n    parser.removeErrorListeners();\n    parser.addErrorListener(errorListener);\n    parser.root();\n\n    const core = new c3.CodeCompletionCore(parser);\n    core.preferredRules = new Set([MySqlParser.RULE_tableName]);\n    const cursorPosition = findCursorTokenIndex(tokenStream, cursor);\n    const suggestKeywords: KeywordSuggestion[] = [];\n\n    if (cursorPosition !== undefined) {\n        const candidates = core.collectCandidates(cursorPosition);\n        candidates.tokens.forEach((_, k) =>\n            suggestKeywords.push({value: parser.vocabulary.getSymbolicName(k) || ''}),\n        );\n    }\n\n    return {errors: errorListener.errors, suggestKeywords};\n}\n"]}